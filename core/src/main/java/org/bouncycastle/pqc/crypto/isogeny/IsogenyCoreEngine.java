package org.bouncycastle.pqc.crypto.isogeny;

import java.math.BigInteger;
import java.security.InvalidParameterException;

/**
 * Main routines for computing isogenies adapted from Luca De Feo's
 * code (https://github.com/defeo/ss-isogeny-software/).
 */
public class IsogenyCoreEngine 
{	
	 private static Fp2Point Pother = null;
	 private static Fp2Point Qother = null;
	 
	 
	 /**
	  * Core routine for the isogeny-based key agreement.
	  * 
	  * @param P first basis point for the torsion subgroup
	  * @param Q second basis point for the torsion subgroup
	  * @param m first part of the secret key
	  * @param n second part of the secret key
	  * @param ell prime factor of the torsion subgroup
	  * @param strategy strategy used to compute the isogeny
	  * @param PotherIn first point to push through the isogeny
	  * @param QotherIn second point to push through the isogeny 
	  */
	 public static Fp2Curve keygen(
			 Fp2Point P,
			 Fp2Point Q,
			 BigInteger m, 
			 BigInteger n,
			 int ell, 
			 int[] strategy, 
			 Fp2Point PotherIn, 
			 Fp2Point QotherIn)
	 {
		 if ((ell!=2) && (ell!=3))
			 throw new InvalidParameterException("Currently only supports ell = 2 or 3.");
		 
		 Fp2Point R = null;

		 if (m.equals(BigInteger.ONE))
		 {
			 Fp2Point nP = new Fp2Point(P.getCurve(), P.getX(), P.getY().negate(), P.getZ());
			 Fp2Point QP = P.shamir(Q, nP, BigInteger.ONE,BigInteger.ONE);
			 R = P.mont_3ladder(n, P, Q, QP);
		 }
		 else if (n.equals(BigInteger.ONE))
		 {
			 Fp2Point nQ = new Fp2Point(Q.getCurve(), Q.getX(), Q.getY().negate(), Q.getZ());
			 Fp2Point QP = P.shamir(P, nQ, BigInteger.ONE, BigInteger.ONE);
			 R = P.mont_3ladder(m, Q, P, QP); 
		 }
		 else
		 {
			 R = P.shamir(P, Q, m, n);
		 }
		 
		 if ((PotherIn==null) && (QotherIn==null))
		 {
			 Fp2Curve outCurve = pushThroughIsogeny(R, ell, strategy, null, null);
			 return outCurve;
		 }
		 else if ((PotherIn!=null) && (QotherIn!=null))
		 {
			 Pother = new Fp2Point(PotherIn);
			 Qother = new Fp2Point(QotherIn);
			 Fp2Curve outCurve = pushThroughIsogeny(R, ell, strategy, Pother, Qother);
			 return outCurve;
		 }
		 else
			 throw new RuntimeException("Both Pother and Qother should be null");
	 }
	
	 /**
	  * Push P and Q through the isogeny of kernel 
	  * generated by R using the given strategy.
	  */
	 private static Fp2Curve pushThroughIsogeny(
			 Fp2Point R,
			 int ell,
			 int[] strategy,
			 Fp2Point P,
			 Fp2Point Q)
	  { 
		  int split, i, first = 1, h = strategy.length - 1;
		  
		  Fp2Curve inCurve = R.getCurve();
		  Fp2Curve outCurve = null;
  	  
		  Fp2Queue tail,tmp;
		  
		  tail = new Fp2Queue();
		  tail.P = R;
		  tail.h = h;
		  
		  while (tail!=null)
		  {
			  h = tail.h;
			  split = strategy[h];
			  
			  while (h>1)
			  {
				  tmp = new Fp2Queue();
				  tmp.P = tail.P;
				  
				  for (i=0; i<h-split; i++)
				  {
					  if (ell==2)
						  tmp.P = tmp.P.twice();
					  else
						  tmp.P = tmp.P.triple();
					  
				  }  
				  
				  tmp.h = split;
				  tail  = tmp.push(tail);
				  h = split;
				  split = strategy[h];
			  }
			  
			  if ((ell==2) && (first==1))
			  {
				  // For ell = 2 on the first iteration we must bring the 
				  // 2-torsion point in (0,0)
				  
				  first = 0;
				  Fp2Point tmpPoint = (Fp2Point)tail.P.twice();
				  Fp2Isogeny.isom d1 = new Fp2Isogeny.isom(inCurve, tmpPoint);
				  outCurve = inCurve = d1.isocurve;
				  
				  for (tmp=tail; tmp!=null; tmp=tmp.prev)
 					  tmp.P = d1.apply(tmp.P);
				  
				  if (P!=null)
					  P = d1.apply(P);
				  if (Q!=null)
					  Q = d1.apply(Q);

			  }
			  
			  if(ell==2)
			  {
				  tmp = tail; 
				  tail = tail.pop();
				  
				  Fp2Isogeny.iso2 d2 = new Fp2Isogeny.iso2(inCurve, tmp.P);
				  outCurve = inCurve = d2.isocurve;
				  
				  for(tmp=tail; tmp!=null; tmp=tmp.prev)
				  {
					  tmp.P = d2.apply(tmp.P);
					  tmp.h = tmp.h-1;
				  }
				  
				  if(P!=null)
					  P = d2.apply(P);
				  if(Q!=null)
					  Q = d2.apply(Q);
			  }
			  
			  if (ell==3)
			  {
				  tmp = tail;
				  tail = tail.pop();
				  
				  Fp2Isogeny.iso3 d3 = new Fp2Isogeny.iso3(inCurve, tmp.P);
				  outCurve = inCurve = d3.isocurve;
				  
				  for(tmp=tail; tmp!=null; tmp=tmp.prev)
				  {
					  tmp.P = d3.apply(tmp.P);
					  tmp.h = tmp.h-1;
				  }
				  
				  if(P!=null)
					  P = d3.apply(P);
				  if(Q!=null)
					  Q = d3.apply(Q);
			  }
			  
		  }  
		  
		  if (ell==2)
		  {
			  // For ell = 2 there are still two steps to go
			  
			  Fp2Isogeny.iso4 d4 = new Fp2Isogeny.iso4(inCurve);
			  outCurve = d4.isocurve;
			  
			  if(P!=null)
				  P=d4.apply(P);
			  if(Q!=null)
				  Q=d4.apply(Q);
		  }
		  
		  Pother = P;
		  Qother = Q;
		  
		  return outCurve;
	  }
	 
	 /**
	  * Get the point P after it has been pushed through
	  * the isogeny.
	  */
	 public static Fp2Point getPhiP()
	 {
		 return Pother;
	 }
	 
	 /**
	  * Get the point Q after it has been pushed through
	  * the isogeny.
	  */	 
	 public static Fp2Point getPhiQ()
	 {
		 return Qother;
	 }
	 
}
